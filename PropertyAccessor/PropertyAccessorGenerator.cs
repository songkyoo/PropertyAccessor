using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using static Macaron.PropertyAccessor.SourceGenerationHelpers;
using static Microsoft.CodeAnalysis.SymbolDisplayFormat;

namespace Macaron.PropertyAccessor;

[Generator]
public sealed class PropertyAccessorGenerator : IIncrementalGenerator
{
    #region Constants
    private const string GetterAttributeSourceText =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.PropertyAccessor
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
            internal sealed class GetterAttribute : Attribute
            {
            }
        }
        """;
    private const string SetterAttributeSourceText =
        """
        // <auto-generated/>
        #nullable enable

        using System;
        using System.Diagnostics;

        namespace Macaron.PropertyAccessor
        {
            [Conditional("SOURCE_GENERATOR_ONLY")]
            [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)]
            internal sealed class SetterAttribute : Attribute
            {
            }
        }
        """;

    private const string GetterAttributeString = "Macaron.PropertyAccessor.GetterAttribute";
    private const string SetterAttributeString = "Macaron.PropertyAccessor.SetterAttribute";
    #endregion

    #region Types
    private sealed record GenerationContext(
        IFieldSymbol DeclaredFieldSymbol,
        bool HasGetterAttribute,
        bool HasSetterAttribute,
        ImmutableArray<Diagnostic> Diagnostics
    );
    #endregion

    #region Static
    private static readonly DiagnosticDescriptor ReadonlyFieldWithSetterAttributeRule =
        new(
            id: "PA0001",
            title: "SetterAttribute cannot be applied to readonly fields",
            messageFormat: "Field '{0}' is marked readonly but has Setter attribute",
            category: "Usage",
            DiagnosticSeverity.Error,
            isEnabledByDefault: true
        );
    #endregion

    #region Static
    private static ImmutableArray<string> GenerateAccessorCode(GenerationContext generationContext)
    {
        var (fieldSymbol, hasGetterAttribute, hasSetterAttribute, _) = generationContext;

        if (!hasGetterAttribute && !hasSetterAttribute)
        {
            return ImmutableArray<string>.Empty;
        }

        var fieldName = fieldSymbol.Name;
        var propertyName = GetPropertyName(fieldName);

        if (propertyName.Length < 1)
        {
            return ImmutableArray<string>.Empty;
        }

        var builder = ImmutableArray.CreateBuilder<string>();

        builder.Add($"public {fieldSymbol.Type.ToDisplayString(FullyQualifiedFormat)} {propertyName}");
        builder.Add($"{{");

        if (hasGetterAttribute)
        {
            builder.Add($"{Space}get => {fieldName};");
        }

        if (hasSetterAttribute)
        {
            builder.Add($"{Space}set => {fieldName} = value;");
        }

        builder.Add($"}}");

        return builder.ToImmutable();

        #region Local Functions
        static string GetPropertyName(string name)
        {
            var prefixRemovedName = Regex.Replace(input: name, pattern: "^(_|m_)", replacement: "");
            return prefixRemovedName.Length < 1
                ? ""
                : char.ToUpperInvariant(prefixRemovedName[0]) + prefixRemovedName[1..];
        }
        #endregion
    }
    #endregion

    #region IIncrementalGenerator Interface
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource(
                hintName: "GetterAttribute.g.cs",
                sourceText: SourceText.From(GetterAttributeSourceText, Encoding.UTF8)
            );
            ctx.AddSource(
                hintName: "SetterAttribute.g.cs",
                sourceText: SourceText.From(SetterAttributeSourceText, Encoding.UTF8)
            );
        });

        IncrementalValuesProvider<GenerationContext> valueProvider = context
            .SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (syntaxNode, _) => syntaxNode is FieldDeclarationSyntax
                {
                    AttributeLists.Count: > 0
                },
                transform: (generatorSyntaxContext, _) =>
                {
                    var semanticModel = generatorSyntaxContext.SemanticModel;
                    var fieldDeclarationSyntax = (FieldDeclarationSyntax)generatorSyntaxContext.Node;
                    var variableDeclarationSyntax = fieldDeclarationSyntax.Declaration.Variables[0];

                    if (semanticModel.GetDeclaredSymbol(variableDeclarationSyntax) is not IFieldSymbol fieldSymbol)
                    {
                        return null;
                    }

                    var hasGetterAttribute = false;
                    var hasSetterAttribute = false;
                    var diagnosticsBuilder = ImmutableArray.CreateBuilder<Diagnostic>();

                    foreach (var attributeData in fieldSymbol.GetAttributes())
                    {
                        var attributeClassString = attributeData.AttributeClass?.ToDisplayString();

                        if (attributeClassString == GetterAttributeString)
                        {
                            hasGetterAttribute = true;
                        }

                        if (attributeClassString == SetterAttributeString)
                        {
                            if (!fieldSymbol.IsReadOnly)
                            {
                                hasSetterAttribute = true;
                            }
                            else
                            {
                                diagnosticsBuilder.Add(Diagnostic.Create(
                                    ReadonlyFieldWithSetterAttributeRule,
                                    fieldSymbol.Locations.FirstOrDefault(),
                                    fieldSymbol.Name
                                ));
                            }
                        }

                        if (hasGetterAttribute && hasSetterAttribute)
                        {
                            break;
                        }
                    }

                    if (hasGetterAttribute || hasSetterAttribute || diagnosticsBuilder.Count > 0)
                    {
                        return new GenerationContext(
                            DeclaredFieldSymbol: fieldSymbol,
                            HasGetterAttribute: hasGetterAttribute,
                            HasSetterAttribute: hasSetterAttribute,
                            Diagnostics: diagnosticsBuilder.ToImmutable()
                        );
                    }
                    else
                    {
                        return null;
                    }
                }
            )
            .Where(static generationContext => generationContext != null)!;

        context.RegisterSourceOutput(valueProvider.Collect(), (sourceProductionContext, generationContexts) =>
        {
            foreach (var pair in generationContexts.GroupBy(
                keySelector: generationContext => generationContext.DeclaredFieldSymbol.ContainingType,
                comparer: SymbolEqualityComparer.Default
            ))
            {
                var builder = ImmutableArray.CreateBuilder<string>();

                foreach (var generationContext in pair)
                {
                    var lines = GenerateAccessorCode(generationContext);
                    if (lines.IsEmpty)
                    {
                        continue;
                    }

                    if (builder.Count > 0)
                    {
                        builder.Add("");
                    }

                    builder.AddRange(lines);

                    foreach (var diagnostic in generationContext.Diagnostics)
                    {
                        sourceProductionContext.ReportDiagnostic(diagnostic);
                    }
                }

                AddSource(
                    context: sourceProductionContext,
                    typeSymbol: (INamedTypeSymbol)pair.Key!,
                    lines: builder.ToImmutable()
                );
            }
        });
    }
    #endregion
}
