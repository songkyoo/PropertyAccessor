# Property Accessor

필드에 어트리뷰트를 적용하거나 지정된 인터페이스를 필드로 선언하는 것으로 프로퍼티를 자동으로 생성하는 C# 소스 제네레이터입니다.

## 빌드하기

다음과 같은 순서로 명령을 수행하여 NuGet 패키지를 생성할 수 있습니다.

```shell
dotnet build -c Release
dotnet pack ./PropertyAccessor/PropertyAccessor.csproj -c Release
```

`./PropertyAccessor/bin/Release/` 폴더에 `nupkg` 확장자를 가지는 패키지가 생성됩니다.

## 사용법

프로퍼티를 자동으로 구현하고자 하는 타입은 `AutoProperty` 어트리뷰트를 적용하고 `partial` 한정자를 추가해야 합니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty]
public partial class Foo
{
}
```

`AutoProperty` 어트리뷰트는 지정된 타입에만 적용됩니다. 중첩된 타입에는 적용되지 않습니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty]
public partial class Foo
{
    public partial class Bar
    {
        [Getter]
        private int _baz;
    }
}
```

위와 같은 코드가 있는 경우 `_baz`에 대한 프로퍼티는 생성되지 않습니다. `_baz`에 대한 프로퍼티를 생성하려면 `Bar` 클래스 선언에 `AutoProperty` 어트리뷰트를 적용해야 합니다.

### Getter, Setter 어트리뷰트를 사용하기

필드에 `Getter`와 `Setter` 어트리뷰트를 적용함으로써 프로퍼티를 추가할 수 있습니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty]
public partial class Foo
{
    [Getter]
    private int _bar;
    
    [Getter, Setter]
    private int _baz;
    
    // readonly 필드에 Setter를 선언하면 set 대신 init을 사용합니다.
    [Getter, Setter]
    private readonly int _qux;
}
```

위 코드는 다음과 같은 코드를 자동으로 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Foo
{
    public int Bar
    {
        get => _bar;
    }

    public int Baz
    {
        get => _baz;
        set => _baz = value;
    }

    public int Qux
    {
        get => _qux;
        init => _qux = value;
    }
}
```

기본적으로 필드 이름의 접두어가 `_` 혹은 `m_`인 경우 이를 제거하고 파스칼 케이스로 변경한 것을 프로퍼티 이름으로 사용합니다.

### IReadOnlyProperty, IReadWriteProperty 인터페이스를 사용하기

`IReadOnlyProperty<TProperty>`, `IReadOnlyProperty<T, TProperty>`, `IReadWriteProperty<TProperty>`, `IReadWriteProperty<T, TProperty>` 중 하나의 타입을 `readonly` 필드 멤버로 선언하면 프로퍼티가 자동으로 생성됩니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty]
public partial class Foo
{
    // readonly로 선언해야 합니다.
    private readonly IReadOnlyProperty<int> _bar;
    
    private readonly IReadOnlyProperty<Foo, int> _baz;

    private readonly IReadWriteProperty<int> _qux;
    
    private readonly IReadWriteProperty<Foo, int> _quux;
}
```

> :warning: 인터페이스를 구현한 타입이 아니라 인터페이스를 사용해야 합니다.

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Foo
{
    public int Bar
    {
        get => _bar.Get(this);
    }

    public int Baz
    {
        get => _baz.Get(this);
    }

    public int Qux
    {
        get => _qux.Get(this);
        set => _qux.Set(this, value);
    }

    public int Quux
    {
        get => _quux.Get(this);
        set => _quux.Set(this, value);
    }
}

```

`IReadOnlyProperty<TProperty>`, `IReadOnlyProperty<T, TProperty>`, `IReadWriteProperty<TProperty>`, `IReadWriteProperty<T, TProperty>` 모두 `this` 인스턴스를 전달하지만 정확한 타입을 사용해야 할 경우 `IReadOnlyProperty<T, TProperty>`, `IReadWriteProperty<T, TProperty>`를 사용합니다.

> :warning: `AutoProperty`가 선언된 타입이 값 타입인 경우 `this`는 복사본으로 전달된다는 점을 주의해야 합니다.

#### IReadOnlyProperty, IReadWriteProperty의 기본 구현체

`IReadOnlyProperty<TProperty>`, `IReadOnlyProperty<T, TProperty>`, `IReadWriteProperty<TProperty>`, `IReadWriteProperty<T, TProperty>`는 직접 인터페이스를 구현해서 사용할 수 있지만 미리 구현된 구현체가 있습니다.

##### ReadOnlyProperty

`IReadOnlyProperty<TProperty>`, `IReadOnlyProperty<T, TProperty>`에 대한 기본 구현을 제공합니다.

```csharp
using Macaron.PropertyAccessor;
using Macaron.PropertyAccessor.Properties;

[AutoProperty]
public partial class Foo
{
    private readonly IReadOnlyProperty<int> _bar = ReadOnlyProperty.Of(getter: () => 42);
    
    private readonly IReadOnlyProperty<int> _baz = ReadOnlyProperty.Of(context: 42, getter: context => context * 7);
    
    private readonly IReadOnlyProperty<Foo, int> _qux = ReadOnlyProperty.For<Foo>.Of(getter: foo => 42);
    
    private readonly IReadOnlyProperty<Foo, int> _quux = ReadOnlyProperty.For<Foo>.Of(
        context: 42,
        getter: (foo, context) => context * 7
    );
}
```

##### ReadWriteProperty

`IReadWriteProperty<TProperty>`, `IReadWriteProperty<T, TProperty>`에 대한 기본 구현을 제공합니다.

```csharp
using Macaron.PropertyAccessor;
using Macaron.PropertyAccessor.Properties;

[AutoProperty]
public partial class Foo
{
    int _barValue;
    int _quxValue;
    
    private readonly IReadWriteProperty<int> _bar;
    
    private readonly IReadWriteProperty<int> _baz;

    private readonly IReadWriteProperty<Foo, int> _qux;
    
    private readonly IReadWriteProperty<Foo, int> _quux;

    public Foo()
    {
        _bar = ReadWriteProperty.Of(
            getter: () => _barValue,
            setter: newValue => _barValue = newValue
        );
        _baz = ReadWriteProperty.Of(
            // 프로퍼티 내부에 있는 값의 타입은 프로퍼티 자체의 타입과 다를 수 있습니다.
            initialValue: 42,
            getter: value => value * 7,
            // setter는 반환되는 값을 사용해서 내부의 값을 설정합니다.
            setter: (oldValue, newValue) => newValue / 7
        );
        _qux = ReadWriteProperty.For<Foo>.Of(
            getter: foo => foo._quxValue,
            setter: (foo, newValue) => foo._quxValue = newValue
        );
        _quux = ReadWriteProperty.For<Foo>.Of(
            initialValue: 42,
            getter: (foo, value) => value * 7,
            setter: (foo, oldValue, newValue) => newValue / 7
        );
    }
}
```

##### LazyProperty

내부적으로 `System.Lazy<T>`를 사용하여 지연 초기화를 수행합니다.

```csharp
using Macaron.PropertyAccessor;
using Macaron.PropertyAccessor.Properties;

[AutoProperty]
public partial class Foo
{
    // 프로퍼티에 처음 접근 할 때 valueFactory를 실행하여 값을 생성합니다.
    private readonly IReadOnlyProperty<int> _bar = LazyProperty.Of(valueFactory: () => 42);
}
```

##### ObservableProperty

지정한 타입의 값을 저장하여 읽고 쓸 수 있고 값을 쓸 때 `onBeforeSet`, `onAfterSet` 델리게이트를 통해 값 변경을 통지합니다.

```csharp
using Macaron.PropertyAccessor;
using Macaron.PropertyAccessor.Properties;

[AutoProperty]
public partial class Foo
{
    private readonly IReadWriteProperty<string> _bar = ObservableProperty.Of(
        initialValue: "Hello, world!",
        onBeforeSet: (oldValue, newValue) =>
        {
            // 값을 설정하기 전 호출됩니다. false를 반환하면 값을 설정하지 않습니다.
            return true;
        },
        onAfterSet: (oldValue, newValue) =>
        {
            // 값을 설정한 후 호출됩니다.
        }
    );

    private readonly IReadWriteProperty<Foo, string> _baz = ObservableProperty.For<Foo>.Of(
        initialValue: "Hello, world!",
        onBeforeSet: (foo, oldValue, newValue) =>
        {
            return true;
        },
        onAfterSet: (foo, oldValue, newValue) =>
        {
        }
    );
}
```

### AutoProperty 옵션

`AutoProperty`는 다음과 같은 옵션을 지정할 수 있습니다.

- `accessModifier` PropertyAccessModifier: 프로퍼티를 생성할 때 사용할 접근 한정자를 지정합니다. 기본값은 `Public`입니다.
- `prefix` string: 필드 이름에서 제거할 접두어를 나타내는 정규식 문자열입니다. 기본값은 `(_|m_)`입니다.
- `namingRule` PropertyNamingRule: 접두어를 제거한 필드 이름을 어떻게 변경할지 결정합니다. 기본값은 `PascalCase`입니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty(
    accessModifier: PropertyAccessModifier.Public,
    prefix: "f",
    namingRule: PropertyNamingRule.CamelCase
)]
public partial class Foo
{
    [Getter]
    private string fName;
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Foo
{
    public string name
    {
        get => fName;
    }
}
```

중첩된 타입에 선언된 `AutoProperty`의 옵션은 외부에 선언된 `AutoProperty` 어트리뷰트의 영향을 받지 않습니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty(
    accessModifier: PropertyAccessModifier.Public,
    prefix: "f",
    namingRule: PropertyNamingRule.CamelCase
)]
public partial class Foo
{
    // 프로퍼티 이름은 name이 됩니다.
    [Getter]
    private string fName;
 
    [AutoProperty]
    public partial class Bar
    {
        // 외부에 선언된 AutoProperty의 설정을 적용하지 않기 때문에 프로퍼티 이름은 FAge가 됩니다.
        [Getter]
        public int fAge;
    }
}
```

#### 멤버에 AutoProperty 선언하기

필드에도 `AutoProperty` 어트리뷰트를 적용할 수 있습니다. 이 경우 기본값은 타입에 적용된 `AutoProperty`의 옵션 값을 따릅니다.

```csharp
using Macaron.PropertyAccessor;

[AutoProperty(accessModifier: PropertyAccessModifier.Protected)]
public partial class Foo
{
    // 지정하지 않은 accessModifier 옵션은 타입에 적용된 AutoProperty에서 지정된 값을 따릅니다.
    [AutoProperty(prefix:"f", namingRule: PropertyNamingRule.CamelCase), Getter]
    private string fName;
}
```

위 코드는 다음과 같은 코드를 생성합니다.

```csharp
// <auto-generated />
#nullable enable

partial class Foo
{
    protected string name
    {
        get => fName;
    }
}
```
